<#@ template language="C#" hostspecific="true" #>
namespace TestRunner
{
    public static class TypeDiscoverer
    {
        private static global::System.Type[] _types;

        public static global::System.Collections.Generic.IEnumerable<global::System.Type> GetAllTypes()
        {
            GetAllTypesPrivate(ref _types);
            return _types;
        }

        private static void GetAllTypesPrivate(ref global::System.Type[] types)
        {
            if (_types != null)
            {
                return;
            }
#if NET20 || NET30 || NET40 || NET45 || NET46 || NET47 || NETCOREAPP1_0 || NETCOREAPP1_1 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETSTANDARD1_5 || NETSTANDARD1_6
            types = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TypeDiscoverer)).Assembly.GetTypes();
#else
<#
	var projectPath = Host.ResolveAssemblyReference("$(ProjectDir)");
	var files = this.DirSearch(projectPath);
	var types = new System.Collections.Generic.List<string>();
	foreach (var file in files)
	{
		if (file.StartsWith(projectPath + "bin"))
		{
			continue;
		}
		if (file.StartsWith(projectPath + "obj"))
		{
			continue;
		}
		if (!file.EndsWith(".cs"))
		{
			continue;
		}
		var text = System.IO.File.ReadAllText(file);
		var stack = new System.Collections.Generic.Stack<System.Tuple<string, int, bool>>();
		var level = 0;
		var currentNamespace = string.Empty;
		var position = 0;
		do
		{
			SkipWhiteSpace(text, ref position);
			if (this.Consume(text, "namespace", ref position))
			{
				SkipWhiteSpace(text, ref position);
				var word = ConsumeWord(text, ref position);
				stack.Push(new System.Tuple<string, int, bool>(word, level, true));
				if (currentNamespace.Length == 0)
				{
					currentNamespace = word;
				}
				else
				{
					currentNamespace += "." + word;
				}
			}
			else if (this.Consume(text, "class", ref position) || this.Consume(text, "struct", ref position))
			{
				SkipWhiteSpace(text, ref position);
				if (char.IsLetterOrDigit(text[position]))
				{
					var allow = stack.Count == 0 || stack.Peek().Item3;
					stack.Push(new System.Tuple<string, int, bool>(currentNamespace, level, false));
					var word = ConsumeWord(text, ref position);
					if (currentNamespace.Length == 0)
					{
						currentNamespace = word;
					}
					else
					{
						currentNamespace += "." + word;
					}
					if (allow)
					{
						types.Add(currentNamespace);
					}
				}
			}
			else if(this.Consume(text, "{", ref position))
			{
				level++;
			}
			else if(this.Consume(text, "}", ref position))
			{
				level--;
				while (stack.Count > 0)
				{
					var found = stack.Peek();
					if (found.Item2 < level)
					{
						break;
					}
					currentNamespace = stack.Pop().Item1;
				}
			}
			else
			{
				ConsumeWord(text, ref position);
			}
		} while(position < text.Length);
	}
#>
            types = new <#= types.Count == 0 ? "global::System.Type" : string.Empty #>[]
			{
<#
	foreach (var type in types)
	{
		var output = type;
		if (output.StartsWith("TestRunner."))
		{
			output = output.Substring("TestRunner.".Length);
		}
#>
				typeof(<#=output #>),
<#
	}
#>
			};
#endif
		}
    }
}
<#+
	public System.Collections.Generic.IEnumerable<string> DirSearch(string dir)
	{
		var queue = new System.Collections.Generic.Queue<string>();
		queue.Enqueue(dir);
		while(queue.Count > 0)
		{
			var current = queue.Dequeue();
			foreach (var file in System.IO.Directory.GetFiles(current))
			{
				yield return file;
			}
			foreach (var directory in System.IO.Directory.GetDirectories(current))
			{
				queue.Enqueue(directory);
			}
		}
	}

	public void SkipWhiteSpace(string text, ref int position)
	{
		var length = text.Length;
		for (var index = position; index < length; index++)
		{
			if (!char.IsWhiteSpace(text[index]))
			{
				position = index;
				return;
			}
		}
		position = length;
	}

	public bool Consume(string text, string match, ref int position)
	{
		var length = match.Length;
		var next = length + position;
		if (next <= text.Length && text.Substring(position, length) == match)
		{
			position = next;
			return true;
		}
		return false;
	}

	public string ConsumeWord(string text, ref int position)
	{
		var length = text.Length;
		for (var index = position; index < length; index++)
		{
			if (char.IsWhiteSpace(text[index]) || text[index] == '{' || text[index] == '}')
			{
				var start = position;
				var diff = index - start;
				position = index;
				return text.Substring(start, diff);
			}
		}
		position = length;
		return text.Substring(position);
	}
#>