<#@ template language="C#" #>// <auto-generated />
<#

var templates = new string[][]
{
    new string[]
    {
        @"int count = 0;
        retry:
            if (@)
            {
                return;
            }
            else
            {
                SpinOnce(ref count);
                goto retry;
            }",
        @"int count = 0;
            var start = TicksNow();
        retry:
            if (@)
            {
                return true;
            }
            else
            {
                if (Milliseconds(TicksNow() - start) < milliseconds)
                {
                    SpinOnce(ref count);
                    goto retry;
                }
                else
                {
                    return false;
                }
            }",
        @"int count = 0;
            var start = DateTime.Now;
        retry:
            if (@)
            {
                return true;
            }
            else
            {
                if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                {
                    SpinOnce(ref count);
                    goto retry;
                }
                else
                {
                    return false;
                }
            }",
        @"int count = 0;
        retry:
            cancellationToken.ThrowIfCancellationRequested();
            GC.KeepAlive(cancellationToken.WaitHandle);
            if (@)
            {
                return;
            }
            else
            {
                SpinOnce(ref count);
                goto retry;
            }",
        @"int count = 0;
            var start = TicksNow();
        retry:
            cancellationToken.ThrowIfCancellationRequested();
            GC.KeepAlive(cancellationToken.WaitHandle);
            if (@)
            {
                return true;
            }
            else
            {
                if (Milliseconds(TicksNow() - start) < milliseconds)
                {
                    SpinOnce(ref count);
                    goto retry;
                }
                else
                {
                    return false;
                }
            }",
        @"int count = 0;
            var start = DateTime.Now;
        retry:
            cancellationToken.ThrowIfCancellationRequested();
            GC.KeepAlive(cancellationToken.WaitHandle);
            if (@)
            {
                return true;
            }
            else
            {
                if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                {
                    SpinOnce(ref count);
                    goto retry;
                }
                else
                {
                    return false;
                }
            }"
    },
    new string[]
    {
        @"int count = 0;
            var start = TicksNow();
        retry:
            @0
            if (@1)
            {
                return true;
            }
            else
            {
                SpinOnce(ref count);
                goto retry;
            }",
        @"int count = 0;
            var start = TicksNow();
        retry:
            @0
            if (@1)
            {
                return true;
            }
            else
            {
                if (Milliseconds(TicksNow() - start) < milliseconds)
                {
                    SpinOnce(ref count);
                    goto retry;
                }
                else
                {
                    return false;
                }
            }",
        @"int count = 0;
            var start = DateTime.Now;
        retry:
            @0
            if (@1)
            {
                return true;
            }
            else
            {
                if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                {
                    SpinOnce(ref count);
                    goto retry;
                }
                else
                {
                    return false;
                }
            }",
        @"int count = 0;
        retry:
            cancellationToken.ThrowIfCancellationRequested();
            GC.KeepAlive(cancellationToken.WaitHandle);
            @0
            if (@1)
            {
                return true;
            }
            else
            {
                SpinOnce(ref count);
                goto retry;
            }",
        @"int count = 0;
            var start = TicksNow();
        retry:
            cancellationToken.ThrowIfCancellationRequested();
            GC.KeepAlive(cancellationToken.WaitHandle);
            @0
            if (@1)
            {
                return true;
            }
            else
            {
                if (Milliseconds(TicksNow() - start) < milliseconds)
                {
                    SpinOnce(ref count);
                    goto retry;
                }
                else
                {
                    return false;
                }
            }",
        @"int count = 0;
            var start = DateTime.Now;
        retry:
            cancellationToken.ThrowIfCancellationRequested();
            GC.KeepAlive(cancellationToken.WaitHandle);
            @0
            if (@1)
            {
                return true;
            }
            else
            {
                if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                {
                    SpinOnce(ref count);
                    goto retry;
                }
                else
                {
                    return false;
                }
            }"
    },
    new string[]
    {
        @"int count = 0;
        retry:
            @0
            if (@1)
            {
                return false;
            }
            else
            {
                @2
                if (@3)
                {
                    return true;
                }
            }
            SpinOnce(ref count);
            goto retry;
            ",
        @"int count = 0;
            var start = TicksNow();
        retry:
            @0
            if (@1)
            {
                return false;
            }
            else
            {
                @2
                if (@3)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }",
        @"int count = 0;
            var start = DateTime.Now;
        retry:
            @0
            if (@1)
            {
                return false;
            }
            else
            {
                @2
                if (@3)
                {
                    return true;
                }
            }
            if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }",
        @"int count = 0;
        retry:
            cancellationToken.ThrowIfCancellationRequested();
            GC.KeepAlive(cancellationToken.WaitHandle);
            @0
            if (@1)
            {
                return false;
            }
            else
            {
                @2
                if (@3)
                {
                    return true;
                }
            }
            SpinOnce(ref count);
            goto retry;
            ",
        @"int count = 0;
            var start = TicksNow();
        retry:
            cancellationToken.ThrowIfCancellationRequested();
            GC.KeepAlive(cancellationToken.WaitHandle);
            @0
            if (@1)
            {
                return false;
            }
            else
            {
                @2
                if (@3)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }",
        @"int count = 0;
            var start = DateTime.Now;
        retry:
            cancellationToken.ThrowIfCancellationRequested();
            GC.KeepAlive(cancellationToken.WaitHandle);
            @0
            if (@1)
            {
                return false;
            }
            else
            {
                @2
                if (@3)
                {
                    return true;
                }
            }
            if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }"
    }
};

var methods0 = new string[][]
{
    new string[]
    {
        "SpinWaitSet",
        "ref int check, int value, int comparand",
        "ref check, value, comparand",
        "Interlocked.CompareExchange(ref check, value, comparand) == comparand",
        ""
    },
    new string[]
    {
        "SpinWaitUntil",
        "ref int check, int comparand",
        "ref check, comparand",
        "Thread.VolatileRead(ref check) == comparand",
        ""
    },
    new string[]
    {
        "SpinWaitUntil",
        "Func<bool> verification",
        "verification",
        "verification.Invoke()",
        ""
    },
    new string[]
    {
        "SpinWaitWhile",
        "ref int check, int comparand",
        "ref check, comparand",
        "Thread.VolatileRead(ref check) != comparand",
        ""
    },
    new string[]
    {
        "SpinWaitWhileNull<T>",
        "ref T check",
        "ref check",
        "!object.ReferenceEquals(VolatileRead<T>(ref check), null)",
        "\r\n        where T : class"
    }
};

var methods1 = new string[][]
{
    new string[]
    {
        "SpinWaitRelativeSet",
        "ref int check, int value",
        "ref check, value",
        "var tmpA = Thread.VolatileRead(ref check);\r\n            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);",
        "tmpB == tmpA",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeExchange",
        "ref int check, int value, out int result",
        "ref check, value, out result",
        "var tmpA = Thread.VolatileRead(ref check);\r\n            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);\r\n            result = tmpB + value;",
        "tmpB == tmpA",
        ""
    }
};

var methods2 = new string[][]
{
    new string[]
    {
        "SpinWaitSetUnless",
        "ref int check, int value, int comparand, int unless",
        "ref check, value, unless",
        "var lastValue = Thread.VolatileRead(ref check);",
        "lastValue == unless",
        "var tmpB = Interlocked.CompareExchange(ref check, value, comparand);",
        "tmpB == comparand",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeSetUnless",
        "ref int check, int value, int unless",
        "ref check, value, unless",
        "var lastValue = Thread.VolatileRead(ref check);\r\n            var result = lastValue + value;",
        "lastValue == unless",
        "var tmpB = Interlocked.CompareExchange(ref check, result, lastValue);",
        "tmpB == lastValue",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeExchangeUnless",
        "ref int check, int value, int unless, out int result",
        "ref check, value, unless, out result",
        "var lastValue = Thread.VolatileRead(ref check);\r\n            result = lastValue + value;",
        "lastValue == unless",
        "var tmpB = Interlocked.CompareExchange(ref check, result, lastValue);",
        "tmpB == lastValue",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeSetUnlessNegative",
        "ref int check, int value",
        "ref check, value",
        "var lastValue = Thread.VolatileRead(ref check);",
        "(lastValue < 0) || (lastValue < -value)",
        "var result = lastValue + value;\r\n                var tmp = Interlocked.CompareExchange(ref check, result, lastValue);",
        "tmp == lastValue",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeExchangeUnlessNegative",
        "ref int check, int value, out int lastValue",
        "ref check, value, out lastValue",
        "lastValue = Thread.VolatileRead(ref check);",
        "(lastValue < 0) || (lastValue < -value)",
        "var result = lastValue + value;\r\n                var tmp = Interlocked.CompareExchange(ref check, result, lastValue);",
        "tmp == lastValue",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeSetUnlessExcess",
        "ref int check, int value, int maxValue",
        "ref check, value, maxValue",
        "var lastValue = Thread.VolatileRead(ref check);",
        "(lastValue > maxValue) || (lastValue > maxValue - value)",
        "var result = lastValue + value;\r\n                var tmp = Interlocked.CompareExchange(ref check, result, lastValue);",
        "tmp == lastValue",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeExchangeUnlessExcess",
        "ref int check, int value, int maxValue, out int lastValue",
        "ref check, value, maxValue, out lastValue",
        "lastValue = Thread.VolatileRead(ref check);",
        "(lastValue > maxValue) || (lastValue > maxValue - value)",
        "var result = lastValue + value;\r\n                var tmp = Interlocked.CompareExchange(ref check, result, lastValue);",
        "tmp == lastValue",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeSetBounded",
        "ref int check, int value, int minValue, int maxValue",
        "ref check, value, minValue, maxValue",
        "var lastValue = Thread.VolatileRead(ref check);",
        "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)",
        "var result = lastValue + value;\r\n                var tmp = Interlocked.CompareExchange(ref check, result, lastValue);",
        "tmp == lastValue",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeExchangeBounded",
        "ref int check, int value, int minValue, int maxValue, out int lastValue",
        "ref check, value, minValue, maxValue, out lastValue",
        "lastValue = Thread.VolatileRead(ref check);",
        "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)",
        "var result = lastValue + value;\r\n                var tmp = Interlocked.CompareExchange(ref check, result, lastValue);",
        "tmp == lastValue",
        ""
    }
};

#>

using System;
using System.Threading;

namespace Theraot.Threading
{
    public static partial class ThreadingHelper
    {<# foreach (var method in methods0){ #>

        public static void <#=method[0]#>(<#=method[1]#>)<#=method[4]#>
        {
            <#= templates[0][0].Replace("@", method[3]) #>
        }

        public static void <#=method[0]#>(<#=method[1]#>, CancellationToken cancellationToken)<#=method[4]#>
        {
            <#= templates[0][3].Replace("@", method[3]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, int milliseconds)<#=method[4]#>
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                <#=method[0]#>(<#=method[2]#>);
                return true;
            }
            <#= templates[0][1].Replace("@", method[3]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, int milliseconds, CancellationToken cancellationToken)<#=method[4]#>
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                <#=method[0]#>(<#=method[2]#>);
                return true;
            }
            <#= templates[0][4].Replace("@", method[3]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, TimeSpan timeout)<#=method[4]#>
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            <#= templates[0][1].Replace("@", method[3]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, TimeSpan timeout, CancellationToken cancellationToken)<#=method[4]#>
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            <#= templates[0][4].Replace("@", method[3]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, IComparable<TimeSpan> timeout)<#=method[4]#>
        {
            <#= templates[0][2].Replace("@", method[3]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, IComparable<TimeSpan> timeout, CancellationToken cancellationToken)<#=method[4]#>
        {
            <#= templates[0][5].Replace("@", method[3]) #>
        }
    <# } #><# foreach (var method in methods1){ #>

        public static bool <#=method[0]#>(<#=method[1]#>)<#=method[5]#>
        {
            <#= templates[1][0].Replace("@0", method[3]).Replace("@1", method[4]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, CancellationToken cancellationToken)<#=method[5]#>
        {
            <#= templates[1][3].Replace("@0", method[3]).Replace("@1", method[4]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, int milliseconds)<#=method[5]#>
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return <#=method[0]#>(<#=method[2]#>);
            }
            <#= templates[1][1].Replace("@0", method[3]).Replace("@1", method[4]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, int milliseconds, CancellationToken cancellationToken)<#=method[5]#>
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return <#=method[0]#>(<#=method[2]#>);
            }
            <#= templates[1][4].Replace("@0", method[3]).Replace("@1", method[4]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, TimeSpan timeout)<#=method[5]#>
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            <#= templates[1][1].Replace("@0", method[3]).Replace("@1", method[4]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, TimeSpan timeout, CancellationToken cancellationToken)<#=method[5]#>
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            <#= templates[1][4].Replace("@0", method[3]).Replace("@1", method[4]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, IComparable<TimeSpan> timeout)<#=method[5]#>
        {
            <#= templates[1][2].Replace("@0", method[3]).Replace("@1", method[4]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, IComparable<TimeSpan> timeout, CancellationToken cancellationToken)<#=method[5]#>
        {
            <#= templates[1][5].Replace("@0", method[3]).Replace("@1", method[4]) #>
        }
    <# } #><# foreach (var method in methods2){ #>

        public static bool <#=method[0]#>(<#=method[1]#>)<#=method[7]#>
        {
            <#= templates[2][0].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, CancellationToken cancellationToken)<#=method[7]#>
        {
            <#= templates[2][3].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, int milliseconds)<#=method[7]#>
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return <#=method[0]#>(<#=method[2]#>);
            }
            <#= templates[2][1].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, int milliseconds, CancellationToken cancellationToken)<#=method[7]#>
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return <#=method[0]#>(<#=method[2]#>);
            }
            <#= templates[2][4].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, TimeSpan timeout)<#=method[7]#>
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            <#= templates[2][1].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, TimeSpan timeout, CancellationToken cancellationToken)<#=method[7]#>
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            <#= templates[2][4].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, IComparable<TimeSpan> timeout)<#=method[7]#>
        {
            <#= templates[2][2].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, IComparable<TimeSpan> timeout, CancellationToken cancellationToken)<#=method[7]#>
        {
            <#= templates[2][5].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }
    <# } #>}
}
