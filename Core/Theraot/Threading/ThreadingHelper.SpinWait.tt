<#@ template language="C#" #>// <auto-generated />
<#

var templates = new string[][]
{
    new string[]
    {
        @"int count = 0;
            if (@)
            {
                return;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (@)
                {
                    return;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }",
        @"int count = 0;
            if (@)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (@)
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }",
        @"int count = 0;
            if (@)
            {
                return true;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                if (@)
                {
                    return true;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }"
    },
    new string[]
    {
        @"int count = 0;
            @0
            if (@2)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                @1
                if (@2)
                {
                    return true;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }",
        @"int count = 0;
            @0
            if (@2)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                @1
                if (@2)
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }",
        @"int count = 0;
            @0
            if (@2)
            {
                return true;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                @1
                if (@2)
                {
                    return true;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }"
    },
    new string[]
    {
        @"int count = 0;
            @0
            if (@2)
            {
                return true;
            }
            else if (@3)
            {
                return false;
            }
            else
            {
                var start = TicksNow();
            retry:
                @1
                if (@2)
                {
                    return true;
                }
                else if (@3)
                {
                    return false;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }",
        @"int count = 0;
            @0
            if (@2)
            {
                return true;
            }
            else if (@3)
            {
                return false;
            }
            else
            {
                var start = TicksNow();
            retry:
                @1
                if (@2)
                {
                    return true;
                }
                else if (@3)
                {
                    return false;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }",
        @"int count = 0;
            @0
            if (@2)
            {
                return true;
            }
            else if (@3)
            {
                return false;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                @1
                if (@2)
                {
                    return true;
                }
                else if (@3)
                {
                    return false;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }"
    },
    new string[]
    {
        @"int count = 0;
        retry:
            @0
            if (@1)
            {
                @2
                if (@3)
                {
                    return true;
                }
            }
            SpinOnce(ref count);
            goto retry;
            ",
        @"int count = 0;
            var start = TicksNow();
        retry:
            @0
            if (@1)
            {
                @2
                if (@3)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }",
        @"int count = 0;
            var start = DateTime.Now;
        retry:
            @0
            if (@1)
            {
                @2
                if (@3)
                {
                    return true;
                }
            }
            if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }"
    }
};

var methods0 = new string[][]
{
    new string[]
    {
        "SpinWaitSet",
        "ref int check, int value, int comparand",
        "ref check, value, comparand",
        "Interlocked.CompareExchange(ref check, value, comparand) == comparand",
        ""
    },
    new string[]
    {
        "SpinWaitUntil",
        "ref int check, int comparand",
        "ref check, comparand",
        "Thread.VolatileRead(ref check) == comparand",
        ""
    },
    new string[]
    {
        "SpinWaitUntil",
        "Func<bool> verification",
        "verification",
        "verification.Invoke()",
        ""
    },
    new string[]
    {
        "SpinWaitWhile",
        "ref int check, int comparand",
        "ref check, comparand",
        "Thread.VolatileRead(ref check) != comparand",
        ""
    },
    new string[]
    {
        "SpinWaitWhileNull<T>",
        "ref T check",
        "ref check",
        "!object.ReferenceEquals(VolatileRead<T>(ref check), null)",
        "\r\n        where T : class"
    }
};

var methods1 = new string[][]
{
    new string[]
    {
        "SpinWaitRelativeSet",
        "ref int check, int value",
        "ref check, value",
        "var tmpA = Thread.VolatileRead(ref check);\r\n            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);",
        "tmpA = Thread.VolatileRead(ref check);\r\n                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);",
        "tmpB == tmpA",
        ""
    }
};

var methods2 = new string[][]
{
    new string[]
    {
        "SpinWaitRelativeSet",
        "ref int check, int value, int unless",
        "ref check, value, unless",
        "var tmpA = Thread.VolatileRead(ref check);\r\n            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);",
        "tmpA = Thread.VolatileRead(ref check);\r\n                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);",
        "tmpB == tmpA",
        "tmpB == unless",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeExchange",
        "ref int check, int value, int unless, out int result",
        "ref check, value, unless, out result",
        "var tmpA = Thread.VolatileRead(ref check);\r\n            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);\r\n            result = tmpB + value;",
        "tmpA = Thread.VolatileRead(ref check);\r\n                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);\r\n                result = tmpB + value;",
        "tmpB == tmpA",
        "tmpB == unless",
        ""
    }
};

var methods3 = new string[][]
{
    new string[]
    {
        "SpinWaitRelativeSetUnlessNegative",
        "ref int check, int value",
        "ref check, value",
        "var tmpA = Thread.VolatileRead(ref check);\r\n            var tmpB = tmpA + value;",
        "tmpA >= 0 && tmpB >= 0",
        "var tmpC = Interlocked.CompareExchange(ref check, tmpB, tmpA);",
        "tmpC == tmpA",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeExchangeUnlessNegative",
        "ref int check, int value, out int result",
        "ref check, value, out result",
        "var tmpA = Thread.VolatileRead(ref check);\r\n            result = tmpA + value;",
        "tmpA >= 0 && result >= 0",
        "var tmpC = Interlocked.CompareExchange(ref check, result, tmpA);",
        "tmpC == tmpA",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeSetUnlessExcess",
        "ref int check, int value, int maxValue",
        "ref check, value, maxValue",
        "var tmpA = Thread.VolatileRead(ref check);\r\n            var tmpB = tmpA + value;",
        "tmpA <= maxValue && tmpB <= maxValue",
        "var tmpC = Interlocked.CompareExchange(ref check, tmpB, tmpA);",
        "tmpC == tmpA",
        ""
    },
    new string[]
    {
        "SpinWaitRelativeExchangeUnlessExcess",
        "ref int check, int value, int maxValue, out int result",
        "ref check, value, out result, maxValue",
        "var tmpA = Thread.VolatileRead(ref check);\r\n            result = tmpA + value;",
        "tmpA <= maxValue && result <= maxValue",
        "var tmpC = Interlocked.CompareExchange(ref check, result, tmpA);",
        "tmpC == tmpA",
        ""
    }
};

#>

using System;
using System.Threading;

namespace Theraot.Threading
{
    public static partial class ThreadingHelper
    {<# foreach (var method in methods0){ #>

        public static void <#=method[0]#>(<#=method[1]#>)<#=method[4]#>
        {
            <#= templates[0][0].Replace("@", method[3]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, int milliseconds)<#=method[4]#>
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                <#=method[0]#>(<#=method[2]#>);
                return true;
            }
            <#= templates[0][1].Replace("@", method[3]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, TimeSpan timeout)<#=method[4]#>
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            <#= templates[0][1].Replace("@", method[3]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, IComparable<TimeSpan> timeout)<#=method[4]#>
        {
            <#= templates[0][2].Replace("@", method[3]) #>
        }
    <# } #><# foreach (var method in methods1){ #>

        public static bool <#=method[0]#>(<#=method[1]#>)<#=method[6]#>
        {
            <#= templates[1][0].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, int milliseconds)<#=method[6]#>
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return <#=method[0]#>(<#=method[2]#>);
            }
            <#= templates[1][1].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, TimeSpan timeout)<#=method[6]#>
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            <#= templates[1][1].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, IComparable<TimeSpan> timeout)<#=method[6]#>
        {
            <#= templates[1][2].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]) #>
        }
    <# } #><# foreach (var method in methods2){ #>

        public static bool <#=method[0]#>(<#=method[1]#>)<#=method[7]#>
        {
            <#= templates[2][0].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, int milliseconds)<#=method[7]#>
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return <#=method[0]#>(<#=method[2]#>);
            }
            <#= templates[2][1].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, TimeSpan timeout)<#=method[7]#>
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            <#= templates[2][1].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, IComparable<TimeSpan> timeout)<#=method[7]#>
        {
            <#= templates[2][2].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }
    <# } #><# foreach (var method in methods3){ #>

        public static bool <#=method[0]#>(<#=method[1]#>)<#=method[7]#>
        {
            <#= templates[3][0].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, int milliseconds)<#=method[7]#>
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return <#=method[0]#>(<#=method[2]#>);
            }
            <#= templates[3][1].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, TimeSpan timeout)<#=method[7]#>
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            <#= templates[3][1].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }

        public static bool <#=method[0]#>(<#=method[1]#>, IComparable<TimeSpan> timeout)<#=method[7]#>
        {
            <#= templates[3][2].Replace("@0", method[3]).Replace("@1", method[4]).Replace("@2", method[5]).Replace("@3", method[6]) #>
        }
    <# } #>}
}
