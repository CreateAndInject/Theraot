// <auto-generated />

using System;
using System.Threading;

namespace Theraot.Threading
{
    public static partial class ThreadingHelper
    {
        public static void SpinWaitSet(ref int check, int value, int comparand)
        {
            int count = 0;
            if (Interlocked.CompareExchange(ref check, value, comparand) == comparand)
            {
                return;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (Interlocked.CompareExchange(ref check, value, comparand) == comparand)
                {
                    return;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }
        }

        public static bool SpinWaitSet(ref int check, int value, int comparand, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                SpinWaitSet(ref check, value, comparand);
                return true;
            }
            int count = 0;
            if (Interlocked.CompareExchange(ref check, value, comparand) == comparand)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (Interlocked.CompareExchange(ref check, value, comparand) == comparand)
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitSet(ref int check, int value, int comparand, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            if (Interlocked.CompareExchange(ref check, value, comparand) == comparand)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (Interlocked.CompareExchange(ref check, value, comparand) == comparand)
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitSet(ref int check, int value, int comparand, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            if (Interlocked.CompareExchange(ref check, value, comparand) == comparand)
            {
                return true;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                if (Interlocked.CompareExchange(ref check, value, comparand) == comparand)
                {
                    return true;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }
    
        public static void SpinWaitUntil(ref int check, int comparand)
        {
            int count = 0;
            if (Thread.VolatileRead(ref check) == comparand)
            {
                return;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (Thread.VolatileRead(ref check) == comparand)
                {
                    return;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }
        }

        public static bool SpinWaitUntil(ref int check, int comparand, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                SpinWaitUntil(ref check, comparand);
                return true;
            }
            int count = 0;
            if (Thread.VolatileRead(ref check) == comparand)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (Thread.VolatileRead(ref check) == comparand)
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitUntil(ref int check, int comparand, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            if (Thread.VolatileRead(ref check) == comparand)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (Thread.VolatileRead(ref check) == comparand)
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitUntil(ref int check, int comparand, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            if (Thread.VolatileRead(ref check) == comparand)
            {
                return true;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                if (Thread.VolatileRead(ref check) == comparand)
                {
                    return true;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }
    
        public static void SpinWaitUntil(Func<bool> verification)
        {
            int count = 0;
            if (verification.Invoke())
            {
                return;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (verification.Invoke())
                {
                    return;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }
        }

        public static bool SpinWaitUntil(Func<bool> verification, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                SpinWaitUntil(verification);
                return true;
            }
            int count = 0;
            if (verification.Invoke())
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (verification.Invoke())
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitUntil(Func<bool> verification, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            if (verification.Invoke())
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (verification.Invoke())
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitUntil(Func<bool> verification, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            if (verification.Invoke())
            {
                return true;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                if (verification.Invoke())
                {
                    return true;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }
    
        public static void SpinWaitWhile(ref int check, int comparand)
        {
            int count = 0;
            if (Thread.VolatileRead(ref check) != comparand)
            {
                return;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (Thread.VolatileRead(ref check) != comparand)
                {
                    return;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }
        }

        public static bool SpinWaitWhile(ref int check, int comparand, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                SpinWaitWhile(ref check, comparand);
                return true;
            }
            int count = 0;
            if (Thread.VolatileRead(ref check) != comparand)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (Thread.VolatileRead(ref check) != comparand)
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitWhile(ref int check, int comparand, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            if (Thread.VolatileRead(ref check) != comparand)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (Thread.VolatileRead(ref check) != comparand)
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitWhile(ref int check, int comparand, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            if (Thread.VolatileRead(ref check) != comparand)
            {
                return true;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                if (Thread.VolatileRead(ref check) != comparand)
                {
                    return true;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }
    
        public static void SpinWaitWhileNull<T>(ref T check)
        where T : class
        {
            int count = 0;
            if (!object.ReferenceEquals(VolatileRead<T>(ref check), null))
            {
                return;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (!object.ReferenceEquals(VolatileRead<T>(ref check), null))
                {
                    return;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }
        }

        public static bool SpinWaitWhileNull<T>(ref T check, int milliseconds)
        where T : class
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                SpinWaitWhileNull<T>(ref check);
                return true;
            }
            int count = 0;
            if (!object.ReferenceEquals(VolatileRead<T>(ref check), null))
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (!object.ReferenceEquals(VolatileRead<T>(ref check), null))
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitWhileNull<T>(ref T check, TimeSpan timeout)
        where T : class
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            if (!object.ReferenceEquals(VolatileRead<T>(ref check), null))
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                if (!object.ReferenceEquals(VolatileRead<T>(ref check), null))
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitWhileNull<T>(ref T check, IComparable<TimeSpan> timeout)
        where T : class
        {
            int count = 0;
            if (!object.ReferenceEquals(VolatileRead<T>(ref check), null))
            {
                return true;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                if (!object.ReferenceEquals(VolatileRead<T>(ref check), null))
                {
                    return true;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }
    
        public static bool SpinWaitRelativeSet(ref int check, int value)
        {
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            if (tmpB == tmpA)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                if (tmpB == tmpA)
                {
                    return true;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }
        }

        public static bool SpinWaitRelativeSet(ref int check, int value, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return SpinWaitRelativeSet(ref check, value);
            }
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            if (tmpB == tmpA)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                if (tmpB == tmpA)
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitRelativeSet(ref int check, int value, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            if (tmpB == tmpA)
            {
                return true;
            }
            else
            {
                var start = TicksNow();
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                if (tmpB == tmpA)
                {
                    return true;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitRelativeSet(ref int check, int value, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            if (tmpB == tmpA)
            {
                return true;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                if (tmpB == tmpA)
                {
                    return true;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }
    
        public static bool SpinWaitRelativeSet(ref int check, int value, int unless)
        {
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            if (tmpB == tmpA)
            {
                return true;
            }
            else if (tmpB == unless)
            {
                return false;
            }
            else
            {
                var start = TicksNow();
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                if (tmpB == tmpA)
                {
                    return true;
                }
                else if (tmpB == unless)
                {
                    return false;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }
        }

        public static bool SpinWaitRelativeSet(ref int check, int value, int unless, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return SpinWaitRelativeSet(ref check, value, unless);
            }
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            if (tmpB == tmpA)
            {
                return true;
            }
            else if (tmpB == unless)
            {
                return false;
            }
            else
            {
                var start = TicksNow();
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                if (tmpB == tmpA)
                {
                    return true;
                }
                else if (tmpB == unless)
                {
                    return false;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitRelativeSet(ref int check, int value, int unless, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            if (tmpB == tmpA)
            {
                return true;
            }
            else if (tmpB == unless)
            {
                return false;
            }
            else
            {
                var start = TicksNow();
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                if (tmpB == tmpA)
                {
                    return true;
                }
                else if (tmpB == unless)
                {
                    return false;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitRelativeSet(ref int check, int value, int unless, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            if (tmpB == tmpA)
            {
                return true;
            }
            else if (tmpB == unless)
            {
                return false;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                if (tmpB == tmpA)
                {
                    return true;
                }
                else if (tmpB == unless)
                {
                    return false;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }
    
        public static bool SpinWaitRelativeExchange(ref int check, int value, int unless, out int result)
        {
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            result = tmpB + value;
            if (tmpB == tmpA)
            {
                return true;
            }
            else if (tmpB == unless)
            {
                return false;
            }
            else
            {
                var start = TicksNow();
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                result = tmpB + value;
                if (tmpB == tmpA)
                {
                    return true;
                }
                else if (tmpB == unless)
                {
                    return false;
                }
                else
                {
                    SpinOnce(ref count);
                    goto retry;
                }
            }
        }

        public static bool SpinWaitRelativeExchange(ref int check, int value, int unless, out int result, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return SpinWaitRelativeExchange(ref check, value, unless, out result);
            }
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            result = tmpB + value;
            if (tmpB == tmpA)
            {
                return true;
            }
            else if (tmpB == unless)
            {
                return false;
            }
            else
            {
                var start = TicksNow();
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                result = tmpB + value;
                if (tmpB == tmpA)
                {
                    return true;
                }
                else if (tmpB == unless)
                {
                    return false;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitRelativeExchange(ref int check, int value, int unless, out int result, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            result = tmpB + value;
            if (tmpB == tmpA)
            {
                return true;
            }
            else if (tmpB == unless)
            {
                return false;
            }
            else
            {
                var start = TicksNow();
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                result = tmpB + value;
                if (tmpB == tmpA)
                {
                    return true;
                }
                else if (tmpB == unless)
                {
                    return false;
                }
                else
                {
                    if (Milliseconds(TicksNow() - start) < milliseconds)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        public static bool SpinWaitRelativeExchange(ref int check, int value, int unless, out int result, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
            result = tmpB + value;
            if (tmpB == tmpA)
            {
                return true;
            }
            else if (tmpB == unless)
            {
                return false;
            }
            else
            {
                var start = DateTime.Now;
            retry:
                tmpA = Thread.VolatileRead(ref check);
                tmpB = Interlocked.CompareExchange(ref check, tmpA + value, tmpA);
                result = tmpB + value;
                if (tmpB == tmpA)
                {
                    return true;
                }
                else if (tmpB == unless)
                {
                    return false;
                }
                else
                {
                    if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
                    {
                        SpinOnce(ref count);
                        goto retry;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }
    
        public static bool SpinWaitRelativeSetUnlessNegative(ref int check, int value)
        {
            int count = 0;
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = tmpA + value;
            if (tmpA >= 0 && tmpB >= 0)
            {
                var tmpC = Interlocked.CompareExchange(ref check, tmpB, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            SpinOnce(ref count);
            goto retry;
            
        }

        public static bool SpinWaitRelativeSetUnlessNegative(ref int check, int value, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return SpinWaitRelativeSetUnlessNegative(ref check, value);
            }
            int count = 0;
            var start = TicksNow();
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = tmpA + value;
            if (tmpA >= 0 && tmpB >= 0)
            {
                var tmpC = Interlocked.CompareExchange(ref check, tmpB, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }

        public static bool SpinWaitRelativeSetUnlessNegative(ref int check, int value, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            var start = TicksNow();
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = tmpA + value;
            if (tmpA >= 0 && tmpB >= 0)
            {
                var tmpC = Interlocked.CompareExchange(ref check, tmpB, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }

        public static bool SpinWaitRelativeSetUnlessNegative(ref int check, int value, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            var start = DateTime.Now;
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = tmpA + value;
            if (tmpA >= 0 && tmpB >= 0)
            {
                var tmpC = Interlocked.CompareExchange(ref check, tmpB, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }
    
        public static bool SpinWaitRelativeExchangeUnlessNegative(ref int check, int value, out int result)
        {
            int count = 0;
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            result = tmpA + value;
            if (tmpA >= 0 && result >= 0)
            {
                var tmpC = Interlocked.CompareExchange(ref check, result, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            SpinOnce(ref count);
            goto retry;
            
        }

        public static bool SpinWaitRelativeExchangeUnlessNegative(ref int check, int value, out int result, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return SpinWaitRelativeExchangeUnlessNegative(ref check, value, out result);
            }
            int count = 0;
            var start = TicksNow();
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            result = tmpA + value;
            if (tmpA >= 0 && result >= 0)
            {
                var tmpC = Interlocked.CompareExchange(ref check, result, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }

        public static bool SpinWaitRelativeExchangeUnlessNegative(ref int check, int value, out int result, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            var start = TicksNow();
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            result = tmpA + value;
            if (tmpA >= 0 && result >= 0)
            {
                var tmpC = Interlocked.CompareExchange(ref check, result, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }

        public static bool SpinWaitRelativeExchangeUnlessNegative(ref int check, int value, out int result, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            var start = DateTime.Now;
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            result = tmpA + value;
            if (tmpA >= 0 && result >= 0)
            {
                var tmpC = Interlocked.CompareExchange(ref check, result, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }
    
        public static bool SpinWaitRelativeSetUnlessExcess(ref int check, int value, int maxValue)
        {
            int count = 0;
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = tmpA + value;
            if (tmpA <= maxValue && tmpB <= maxValue)
            {
                var tmpC = Interlocked.CompareExchange(ref check, tmpB, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            SpinOnce(ref count);
            goto retry;
            
        }

        public static bool SpinWaitRelativeSetUnlessExcess(ref int check, int value, int maxValue, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return SpinWaitRelativeSetUnlessExcess(ref check, value, maxValue);
            }
            int count = 0;
            var start = TicksNow();
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = tmpA + value;
            if (tmpA <= maxValue && tmpB <= maxValue)
            {
                var tmpC = Interlocked.CompareExchange(ref check, tmpB, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }

        public static bool SpinWaitRelativeSetUnlessExcess(ref int check, int value, int maxValue, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            var start = TicksNow();
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = tmpA + value;
            if (tmpA <= maxValue && tmpB <= maxValue)
            {
                var tmpC = Interlocked.CompareExchange(ref check, tmpB, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }

        public static bool SpinWaitRelativeSetUnlessExcess(ref int check, int value, int maxValue, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            var start = DateTime.Now;
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            var tmpB = tmpA + value;
            if (tmpA <= maxValue && tmpB <= maxValue)
            {
                var tmpC = Interlocked.CompareExchange(ref check, tmpB, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }
    
        public static bool SpinWaitRelativeExchangeUnlessExcess(ref int check, int value, int maxValue, out int result)
        {
            int count = 0;
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            result = tmpA + value;
            if (tmpA <= maxValue && result <= maxValue)
            {
                var tmpC = Interlocked.CompareExchange(ref check, result, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            SpinOnce(ref count);
            goto retry;
            
        }

        public static bool SpinWaitRelativeExchangeUnlessExcess(ref int check, int value, int maxValue, out int result, int milliseconds)
        {
            if (milliseconds < -1)
            {
                throw new ArgumentOutOfRangeException("milliseconds");
            }
            else if (milliseconds == -1)
            {
                return SpinWaitRelativeExchangeUnlessExcess(ref check, value, out result, maxValue);
            }
            int count = 0;
            var start = TicksNow();
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            result = tmpA + value;
            if (tmpA <= maxValue && result <= maxValue)
            {
                var tmpC = Interlocked.CompareExchange(ref check, result, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }

        public static bool SpinWaitRelativeExchangeUnlessExcess(ref int check, int value, int maxValue, out int result, TimeSpan timeout)
        {
            var milliseconds = (long)timeout.TotalMilliseconds;
            int count = 0;
            var start = TicksNow();
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            result = tmpA + value;
            if (tmpA <= maxValue && result <= maxValue)
            {
                var tmpC = Interlocked.CompareExchange(ref check, result, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (Milliseconds(TicksNow() - start) < milliseconds)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }

        public static bool SpinWaitRelativeExchangeUnlessExcess(ref int check, int value, int maxValue, out int result, IComparable<TimeSpan> timeout)
        {
            int count = 0;
            var start = DateTime.Now;
        retry:
            var tmpA = Thread.VolatileRead(ref check);
            result = tmpA + value;
            if (tmpA <= maxValue && result <= maxValue)
            {
                var tmpC = Interlocked.CompareExchange(ref check, result, tmpA);
                if (tmpC == tmpA)
                {
                    return true;
                }
            }
            if (timeout.CompareTo(DateTime.Now.Subtract(start)) > 0)
            {
                SpinOnce(ref count);
                goto retry;
            }
            else
            {
                return false;
            }
        }
    }
}
