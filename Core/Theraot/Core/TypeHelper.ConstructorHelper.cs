// <auto-generated />
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Text;

namespace Theraot.Core
{
    public static partial class TypeHelper
    {
        public static TReturn Create<TReturn>()
        {
            if (ConstructorHelper<TReturn>.HasConstructor)
            {
                return ConstructorHelper<TReturn>.InvokeConstructor();
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with no type arguments.", typeof(TReturn)));
            }
        }

        public static TReturn CreateOrDefault<TReturn>()
        {
            return ConstructorHelper<TReturn>.CreateOrDefault();
        }

        public static Func<TReturn> GetCreate<TReturn>()
        {
            if (ConstructorHelper<TReturn>.HasConstructor)
            {
                return ConstructorHelper<TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with no type arguments.", typeof(TReturn)));
            }
        }

        public static Func<TReturn> GetCreateOrDefault<TReturn>()
        {
            return ConstructorHelper<TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<TReturn>()
        {
            return ConstructorHelper<TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<TReturn> create;
            private static readonly Func<TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = Type.EmptyTypes;
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor()
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T, TReturn>(T obj)
        {
            if (ConstructorHelper<T, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T, TReturn>.InvokeConstructor(obj);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type argument {1}", typeof(TReturn), typeof(T).Name));
            }
        }

        public static TReturn CreateOrDefault<T, TReturn>(T obj)
        {
            return ConstructorHelper<T, TReturn>.CreateOrDefault(obj);
        }

        public static Func<T, TReturn> GetCreate<T, TReturn>()
        {
            if (ConstructorHelper<T, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type argument {1}", typeof(TReturn), typeof(T).Name));
            }
        }

        public static Func<T, TReturn> GetCreateOrDefault<T, TReturn>()
        {
            return ConstructorHelper<T, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T, TReturn>()
        {
            return ConstructorHelper<T, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T, TReturn> create;
            private static readonly Func<T, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T obj)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, TReturn>(T1 arg1, T2 arg2)
        {
            if (ConstructorHelper<T1, T2, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, TReturn>.InvokeConstructor(arg1, arg2);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, TReturn>(T1 arg1, T2 arg2)
        {
            return ConstructorHelper<T1, T2, TReturn>.CreateOrDefault( arg1,  arg2);
        }

        public static Func<T1, T2, TReturn> GetCreate<T1, T2, TReturn>()
        {
            if (ConstructorHelper<T1, T2, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name));
            }
        }

        public static Func<T1, T2, TReturn> GetCreateOrDefault<T1, T2, TReturn>()
        {
            return ConstructorHelper<T1, T2, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, TReturn>()
        {
            return ConstructorHelper<T1, T2, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, TReturn> create;
            private static readonly Func<T1, T2, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, TReturn>(T1 arg1, T2 arg2, T3 arg3)
        {
            if (ConstructorHelper<T1, T2, T3, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, TReturn>.InvokeConstructor(arg1, arg2, arg3);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, TReturn>(T1 arg1, T2 arg2, T3 arg3)
        {
            return ConstructorHelper<T1, T2, T3, TReturn>.CreateOrDefault( arg1,  arg2,  arg3);
        }

        public static Func<T1, T2, T3, TReturn> GetCreate<T1, T2, T3, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name));
            }
        }

        public static Func<T1, T2, T3, TReturn> GetCreateOrDefault<T1, T2, T3, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, TReturn> create;
            private static readonly Func<T1, T2, T3, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            if (ConstructorHelper<T1, T2, T3, T4, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            return ConstructorHelper<T1, T2, T3, T4, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4);
        }

        public static Func<T1, T2, T3, T4, TReturn> GetCreate<T1, T2, T3, T4, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name));
            }
        }

        public static Func<T1, T2, T3, T4, TReturn> GetCreateOrDefault<T1, T2, T3, T4, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5);
        }

        public static Func<T1, T2, T3, T4, T5, TReturn> GetCreate<T1, T2, T3, T4, T5, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6);
        }

        public static Func<T1, T2, T3, T4, T5, T6, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, T7, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, T7, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7);
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, T7, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, T7, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, T7, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, T7, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8);
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, T7, T8, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9);
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10);
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11);
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}, {12}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name, typeof(T12).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11,  arg12);
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}, {12}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name, typeof(T12).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}, {12}, {13}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name, typeof(T12).Name, typeof(T13).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11,  arg12,  arg13);
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}, {12}, {13}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name, typeof(T12).Name, typeof(T13).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}, {12}, {13}, {14}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name, typeof(T12).Name, typeof(T13).Name, typeof(T14).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11,  arg12,  arg13,  arg14);
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}, {12}, {13}, {14}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name, typeof(T12).Name, typeof(T13).Name, typeof(T14).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}, {12}, {13}, {14}, {15}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name, typeof(T12).Name, typeof(T13).Name, typeof(T14).Name, typeof(T15).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11,  arg12,  arg13,  arg14,  arg15);
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}, {12}, {13}, {14}, {15}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name, typeof(T12).Name, typeof(T13).Name, typeof(T14).Name, typeof(T15).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
        public static TReturn Create<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>.InvokeConstructor(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}, {12}, {13}, {14}, {15}, {16}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name, typeof(T12).Name, typeof(T13).Name, typeof(T14).Name, typeof(T15).Name, typeof(T16).Name));
            }
        }

        public static TReturn CreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>.CreateOrDefault( arg1,  arg2,  arg3,  arg4,  arg5,  arg6,  arg7,  arg8,  arg9,  arg10,  arg11,  arg12,  arg13,  arg14,  arg15,  arg16);
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn> GetCreate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>()
        {
            if (ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>.HasConstructor)
            {
                return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>.Create;
            }
            else
            {
                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "There is no constructor for {0} with the type arguments {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}, {12}, {13}, {14}, {15}, {16}", typeof(TReturn), typeof(T1).Name, typeof(T2).Name, typeof(T3).Name, typeof(T4).Name, typeof(T5).Name, typeof(T6).Name, typeof(T7).Name, typeof(T8).Name, typeof(T9).Name, typeof(T10).Name, typeof(T11).Name, typeof(T12).Name, typeof(T13).Name, typeof(T14).Name, typeof(T15).Name, typeof(T16).Name));
            }
        }

        public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn> GetCreateOrDefault<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>.CreateOrDefault;
        }

        public static bool HasConstructor<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>()
        {
            return ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>.HasConstructor;
        }

        private static class ConstructorHelper<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>
        {
            private static readonly ConstructorInfo constructorInfo;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn> create;
            private static readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn> createOrDefault;

            static ConstructorHelper()
            {
                Type[] typeArguments = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16) };
                constructorInfo = typeof(TReturn).GetConstructor(typeArguments);
                create = InvokeConstructor;
                if (HasConstructor)
                {
                    createOrDefault = FuncHelper.GetDefaultFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn>();
                }
                else
                {
                    createOrDefault = create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn> Create
            {
                get
                {
                    return create;
                }
            }

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TReturn> CreateOrDefault
            {
                get
                {
                    return createOrDefault;
                }
            }

            public static bool HasConstructor
            {
                get
                {
                    return constructorInfo == null;
                }
            }

            public static TReturn InvokeConstructor(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)
            {
                return (TReturn)constructorInfo.Invoke(_emptyObjects);
            }
        }
    }
}